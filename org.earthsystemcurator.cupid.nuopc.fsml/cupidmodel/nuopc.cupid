language NUOPC 'http://www.earthsystemcurator.org/nuopcgen' {

	top concept NUOPCApplication 
	{	
		@label = "NUOPC Application"
		@doc = "A collection of interoperable NUOPC components"
		
		attrib name	{ @name }
		
		
		models*:NUOPCModel
		drivers*:NUOPCDriver
		driversAtmOcn*:NUOPCDriverAtmOcn
		
	}
	
	concept NUOPCDriver <module> 
	{
		@label="NUOPC Driver"
		@doc = "A type of NUOPC component that controls its child components"
		
		attrib driverName <moduleName> 
		{
			@name
			@label="Driver Name"
			@default = "NUOPCDriver"
		}
		
		standardESMFImport <usesModule(ESMF)> {@label = "ESMF Import"}
		standardNUOPCImport <usesModule(NUOPC)> {@label = "NUOPC Import"}
		
		genericDriverImports! <usesModule(NUOPC_Driver)>
		{
			@label = "Generic Driver Imports"
			attrib importsGenericSS! <usesEntity(routine_SetServices)>
			attrib importsTypeInternalState <usesEntity(type_InternalState)>
			attrib importsLabelInternalState <usesEntity(label_InternalState)>
			attrib importsLabelSetModelCount <usesEntity(label_SetModelCount)>
			attrib importsLabelSetModelServices <usesEntity(label_SetModelServices)>
		}
		
		modelImports {
			@label = "Child Model Imports"
			
		 	modelImport* <usesModule(#modelImportName)> {
				@label = "Child Import"
				attrib modelImportName
				--ref modelRef = ^models[modelName=modelImportName]
			}
			
			
		}
		
		implementsSetServices <subroutine(SetServices)> {
			
			callsGenericSetServices <call(#^genericDriverImports/importsGenericSS)>
			
			callsMethodAdd* <call(ESMF_MethodAdd(*, #label, *, *))> {
				attrib label
			}
		}
		
	}
	
	concept NUOPCDriverAtmOcn <module> 
	{
		@label="NUOPC Atm-Ocn Driver"
				
		attrib driverName <moduleName> 
		{
			@name
			@label="Driver Name"
		}
		
		standardESMFImport <usesModule(ESMF)> {@label = "ESMF Import"}
		standardNUOPCImport <usesModule(NUOPC)> {@label = "NUOPC Import"}
		
		genericDriverImports! <usesModule(NUOPC_DriverAtmOcn)>
		{
			@label = "Generic Driver Atm-Ocn Imports"
			attrib importsGenericSS! <usesEntity(routine_SetServices)>
			attrib importsTypeInternalState <usesEntity(type_InternalState)>
			attrib importsLabelInternalState <usesEntity(label_InternalState)>
			attrib importsLabelSetModelPetLists <usesEntity(label_SetModelPetLists)>
			attrib importsLabelSetModelServices <usesEntity(label_SetModelServices)>
		}
		
		connectorImport <usesModule(NUOPC_Connector)> {
			@label = "Generic Connector Imports"
			attrib importsSetServices <usesEntity(routine_SetServices)>
		}
		
		implementsSetServices <subroutine(SetServices(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc))> {
			@label = "Set Services"		
			
			attrib p_gcomp
			attrib p_rc
			
			callsGenericSetServices <call(#^genericDriverImports/importsGenericSS)>
			{
				@label = "Calls Generic Driver Atm-Ocn Set Services"
			}
		}
		
		implementsSetModelPetLists <subroutine(*(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc) )> 
		{
			
			@label = "Set Model PET Lists"
			attrib n_SetModelPetLists <subroutineName> {@name}
			attrib p_gcomp
			attrib p_rc	
			
			attrib importsLabelSetModelPetLists! <#^genericDriverImports usesEntity(label_SetModelPetLists)>
					
			--method registration
			setModelPetListsRegistered! <#^implementsSetServices 
					call(ESMF_MethodAdd(#^implementsSetServices/p_gcomp, 
										label=#^genericDriverImports/importsLabelSetModelPetLists, 
										userRoutine=#^n_SetModelPetLists, 
										rc=#^implementsSetServices/p_rc))>
			{
				@label = "Registered in Set Services"
			}
			
			--TODO: deal with internal state stuff
			
		}
		
		implementsSetModelServices <subroutine(*(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc) )> 
		{
			
			@label = "Set Model Services"
			attrib n_SetModelServices <subroutineName> {@name}
			attrib p_gcomp
			attrib p_rc	
			
			--imports label
			attrib importsLabelSetModelServices! <#^genericDriverImports usesEntity(label_SetModelServices)>			
			
			--method registration
			setModelPetListsRegistered! <#^implementsSetServices 
					call(ESMF_MethodAdd(#^implementsSetServices/p_gcomp, 
										label=#^genericDriverImports/importsLabelSetModelServices, 
										userRoutine=#^n_SetModelServices, 
										rc=#^implementsSetServices/p_rc))>
			{
				@label = "Registered in Set Services"
			}
			
			
		}
		
	}
		
	
	concept NUOPCModel <module(#modelName)>
	{
		@label="NUOPC Model"
		@doc="NUOPC Model is a generic model component that wraps a model code so it is suitable to be plugged into a generic Driver component."
				
		attrib modelName
		{
			@name
			@label="Model Name"
			@default = "NUOPCModel"
		}
		
		genericImports! <usesModule(NUOPC_Model)>
		{
			@label = "Generic Imports"
			attrib importsGenericSS! <usesEntity(routine_SetServices)> {@default = "model_routine_SetServices"}
			--attrib importsLabelModelAdvance <usesEntity(label_Advance)>
			--attrib importsLabelSetClock <usesEntity(label_SetClock)>
			
		}
		
		implementsSetServices! <subroutine(*(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc) )> 
		{
			@label = "Set Services"
			attrib n_SetServices <subroutineName> {@name @default="SetServices"}
			attrib p_gcomp {@default="gcomp"}
			attrib p_rc	{@default="rc"}	
						
			callsGenericSetServices! <call(#^genericImports/importsGenericSS(#^p_gcomp, #^p_rc))> 
			{
				@label = "Calls generic SetServices"	
			}
			
			/*
			afterTest* {
				
				first <call(#name)> 
					{attrib name {@name}}
					
				second <call(#name) after(#^first)> 
					{attrib name {@name}}
				
			}
			*/
			
		}
		
		initialize
		{
			@label = "Initialization"
			
			initP1 <subroutine(#n_initP1(
										inout type(ESMF_GridComp) #p_gcomp, 
										inout type(ESMF_State) #p_import, 
										inout type(ESMF_State) #p_export, 
										inout type(ESMF_Clock) #p_clock, 
										out integer #p_rc))>
			{
				@label = "phase 1"
				@doc = "Required and implementor provided. Advertise Fields in import and export States"
				
				attrib n_initP1 {@name @default="InitializeP1"}
				attrib p_gcomp {@default="gcomp"}
				attrib p_import {@default="importState"}
				attrib p_export {@default="exportState"}
				attrib p_clock {@default="clock"}
				attrib p_rc {@default="rc"}
	
				advertisesImportField* <call(NUOPC_StateAdvertiseField(#^p_import, StandardName=#importStandardName, #^p_rc))> 
				{
					@label = "Advertises import field"
					attrib importStandardName {
						@label = "Standard Name"
						@default = "\"standard_name\""
					}
				}
				
				
				advertisesExportField* <call(NUOPC_StateAdvertiseField(#^p_export, StandardName=#exportStandardName, #^p_rc))> 
				{
					@label = "Advertises export field"
					attrib exportStandardName {
						@label = "Standard Name"
						@default = "\"standard_name\""
					}
				}
				
				
				registered1! <#^implementsSetServices call(ESMF_GridCompSetEntryPoint(#^implementsSetServices/p_gcomp, ESMF_METHOD_INITIALIZE, userRoutine=#^n_initP1, phase=1, rc=#^implementsSetServices/p_rc))> 
				{
					@label = "Registered in Set Services"
				--	attrib userRoutine <actualParamByKeyword(userRoutine)>
				--	attrib phase <actualParamByKeyword(phase)>
				}
								
			}
		
			
			initP2 <subroutine(#n_initP2(
						inout type(ESMF_GridComp) #p_gcomp, 
						inout type(ESMF_State) #p_import, 
						inout type(ESMF_State) #p_export, 
						inout type(ESMF_Clock) #p_clock, 
						out integer #p_rc))>
			{
				@label = "phase 2"
				@doc = "Required and implementor provided. Realize the advertised Fields in import and export States"
				
				attrib n_initP2 {@name @default="InitializeP2"}
				attrib p_gcomp {@default="gcomp"}
				attrib p_import {@default="importState"}
				attrib p_export {@default="exportState"}
				attrib p_clock {@default="clock"}
				attrib p_rc {@default="rc"}
												
				--create and realize an import field
				createAndRealizeImport* {
					@label = "Create and Realize Import Field"
					
					-- local variables
					fieldDeclaration <declaration(type(ESMF_Field))> {
						@label = "Declare ESMF_Field"
						attrib fieldName <declaredEntity> {
							@name 
							@label="name" 
							@default="field"
						}
					}
					
					gridDeclaration <declaration(type(ESMF_Grid))> {
						@label = "Declare ESMF_Grid"
						attrib gridName <declaredEntity> {
							@name
							@label="name"
							@default="grid"
						}
					}
					
					-- field = ESMF_FieldCreate(name="sst", grid=gridIn, typekind=ESMF_TYPEKIND_R8, rc=rc)
					fieldAssignment <functionAssignment(#^fieldDeclaration/fieldName, ESMF_FieldCreate(name=#name, grid?=#^gridDeclaration/gridName, typekind?=#typekind, rc?=#^p_rc))>
					{
						@label = "Create field"
						attrib name {@name @default="\"field_name\""}
						attrib typekind {@default="ESMF_TYPEKIND_R8"}
					}
					
					realizesImportField! <call(NUOPC_StateRealizeField(#^p_import, field=#^fieldDeclaration/fieldName, rc=#^p_rc)) after(#^fieldAssignment)> 
					{
						@label = "Realize field"
					}
					
					dummyAssignment!! <functionAssignment(#^fieldDeclaration/fieldName, *) before(#^realizesImportField) after(#^fieldAssignment)>					
				
				}
				
					
				createAndRealizeExport* {
					@label = "Create and Realize Export Field"
					
					-- local variable
					fieldDeclaration <declaration(type(ESMF_Field))> {
						@label = "Declare ESMF_Field"
						attrib fieldName <declaredEntity> {
							@name 
							@label="name" 
							@default="field"
						}
					}
					
					gridDeclaration <declaration(type(ESMF_Grid))> {
						@label = "Declare ESMF_Grid"
						attrib gridName <declaredEntity> {
							@name
							@label="name"
							@default="grid"
						}
					}
					
					-- field = ESMF_FieldCreate(name="sst", grid=gridIn, typekind=ESMF_TYPEKIND_R8, rc=rc)
					fieldAssignment <functionAssignment(#^fieldDeclaration/fieldName, ESMF_FieldCreate(name=#name, grid?=#^gridDeclaration/gridName, typekind?=#typekind, rc?=#^p_rc))>
					{
						@label = "Create field"
						attrib name {@name @default="\"field_name\""}
						attrib typekind {@default="ESMF_TYPEKIND_R8"}
					}
					
					realizesExportField! <call(NUOPC_StateRealizeField(#^p_export, field=#^fieldDeclaration/fieldName, rc=#^p_rc)) after(#^fieldAssignment)> 
					{
						@label = "Realize field"
					}
					
					-- !! indicates that is mustBeNull
					-- this makes sure that there are no changes to field between when the
					-- field is created and when it is realized
					-- TODO: implement a raw <assignment> mapping that ignore the type of assignment, just checks lhs
					-- TODO: fix the bug that a mapped element comes after itself....
					dummyAssignment!! <functionAssignment(#^fieldDeclaration/fieldName, *) before(#^realizesExportField) after(#^fieldAssignment)>
					
				}
				
				
				
				/*
				realizesExportField* <call(NUOPC_StateRealizeField(#^p_export, field=#exportedField, rc=#^p_rc))> 
				{
					@label = "Realizes export field"
					attrib exportedField
				}
				*/
				
				registered2! <#^implementsSetServices call(ESMF_GridCompSetEntryPoint(
						#^implementsSetServices/p_gcomp, 
						ESMF_METHOD_INITIALIZE, 
						userRoutine=#^n_initP2, 
						phase=2, 
						rc=#^implementsSetServices/p_rc))>
				{
					@label = "Registered in Set Services"
				}
						
				--realizesAtLeastOneField
				--realizesOrRegistered
			}
		
			initP3 {
				@label = "phase 3"
				@doc = "Provided by NUOPC. If not set, internal clock is set to copy of incoming clock. Check compatibility, ensuring all advertised import Fields are connected."
			
				specSetClock? <subroutine(*(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc) )> 
				{
					@label = "Set Clock (optional specialization)"
					@doc = "Optional specialization to set the Model's internal clock and/or alarms."
					
					attrib n_SetClock <subroutineName> {@name @default="SetModelClock"}
					attrib p_gcomp {@default="gcomp"}
					attrib p_rc	{@default="rc"}
					
					clock <declaration(type(ESMF_Clock))> 
					{
						attrib name <declaredEntity> {@default="clock"}
					}
					
					timeStep <declaration(type(ESMF_TimeInterval))> 
					{
						attrib name <declaredEntity> {@default="timeStep"}
					}
					
					--imports label
					attrib importsLabelSetClock! <#^genericImports usesEntity(label_SetClock)> {
						@default = "model_label_SetClock"
					}		
					
					--method registration
					setClockRegistered! <#^implementsSetServices 
							call(ESMF_MethodAdd(#^implementsSetServices/p_gcomp, 
												label=#^importsLabelSetClock, 
												userRoutine=#^n_SetClock, 
												rc=#^implementsSetServices/p_rc))>
					{
						@label = "Registered in Set Services"
					}
					
					--call NUOPC_GridCompSetClock(gcomp, clock, stabilityTimeStep, rc=rc)
					setModelClock <call (NUOPC_GridCompSetClock(#^p_gcomp, #^clock/name, #^timeStep/name, rc=#^p_rc))> 
					{
						@label = "Set Clock"
						@doc = "Sets the Component internal Clock as a copy of externalClock, but with a timeStep that is less than or equal to the stabilityTimeStep. At the same time ensures that the timeStep of the external Clock is a multiple of the internal Clock's timeStep. If the stabilityTimeStep argument is not provided then the internal Clock will simply be set as a copy of the externalClock."
					}
					
					
				}
				
			}
			
			initP4 {
				@label = "phase 4"
				@doc = "Provided by NUOPC. Field in export state are timestamped for compatibility checking."
				
				specDataInitialize {
					@label = "Data Initialize (optional specialization)"
					@doc = "Optional specialization to initialize export Fields"
				}
			}
			
			initP5 {
				@label = "phase 5"
				@doc = "Provided by NUOPC. Field in export state are timestamped for compatibility checking."
				
				specDataInitialize {
					@label = "Data Initialize (optional specialization)"
					@doc = "Optional specialization to initialize export Fields"
				}
			}
			
		}	
		
		
		modelRun
		{
			@label = "Run"
			
			runP1 {
				@label = "phase 1"
				@doc = "Provided by NUOPC. Assigns driverClock as alias to incoming clock. Checks compatibility of incoming clock. Checks compatibility of import Fields timestamps. Performs model timestep loop. Timestamps all export Fields."
			}
			
			specSetRunClock? {
				@label = "Set Run Clock (optional specialization)"
				@doc = "Optional specialization to check and set the internal clock against the incoming clock."
			}
			
			specCheckImport? {
				@label = "Check Fields in import State (optional specialization)"
				@doc = "Optional specialization to check Fields in import State."
			}
			
			specModelAdvance {
				@label = "Model Advance (required specialization)" 
				@doc = "Required specialization. Advance the model one time step. May be multi-phase."
				
				--imports label
				attrib importsLabelModelAdvance! <#^genericImports usesEntity(label_Advance)>
				{
					@default = "model_label_Advance"
				}	
				
				modelAdvancePhase+ <subroutine(#userRoutine(inout type(ESMF_GridComp) #p_gcomp, out integer #p_rc))> 
				{	
					@label = "Model Advance Phase"
					@doc = "A single model advance phase"
									
					attrib userRoutine  {@name @default="ModelAdvance"}
					attrib p_gcomp {@default="gcomp"}
					attrib p_rc {@default="rc"}
					attrib phase?
									
					modelAdvanceRegistered! <#^implementsSetServices 
						call(ESMF_MethodAdd(*, 
											index?=#^phase, 
											label=#^importsLabelModelAdvance, 
											userRoutine=#^userRoutine, 
											rc=#^implementsSetServices/p_rc))>
					{
						@label = "Registered in Set Services"
					}
				
				}
			}
			
		}
		
		finalize? <subroutine(#n_finalize(
						inout type(ESMF_GridComp) #p_gcomp, 
						inout type(ESMF_State) #p_import, 
						inout type(ESMF_State) #p_export, 
						inout type(ESMF_Clock) #p_clock, 
						out integer #p_rc))>
		{
			@label = "Finalize"
			@doc = "NUOPC Provided.  Optionally overwrite the provided NOOP with model finalization code."
			
			attrib n_finalize {@default="Finalize"}
			attrib p_gcomp {@default="gcomp"}
			attrib p_import {@default="importState"}
			attrib p_export {@default="exportState"}
			attrib p_clock {@default="clock"}
			attrib p_rc {@default="rc"}
			attrib phase {@default="1"}
			
			registered! <#^implementsSetServices call(ESMF_GridCompSetEntryPoint(
						#^implementsSetServices/p_gcomp, 
						ESMF_METHOD_FINALIZE, 
						userRoutine=#^n_finalize, 
						phase?=#^phase, 
						rc=#^implementsSetServices/p_rc))>
				{
					@label = "Registered in Set Services"
				}
			
		}
		
		
		
				
	}
	
	concept NUOPCMediator <module> 
	{
		@label="NUOPC Mediator"
	}
	
}
