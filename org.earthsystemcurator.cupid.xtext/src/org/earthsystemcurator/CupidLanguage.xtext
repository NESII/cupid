grammar org.earthsystemcurator.CupidLanguage with org.eclipse.xtext.common.Terminals 

generate cupidLanguage "http://www.earthsystemcurator.org/CupidLanguage"

Language:
	'language ' name=ID uri=STRING '{' conceptDef+=TopConceptDef conceptDef+=NamedConceptDef* '}';

//Subconcept:
//	AnonymousConcept | ConceptRef | Attribute;
	
//Subconcept:
//	attrib?='attrib'? name=ID cardinality=Cardinality? essential?='!'?
//	(
//		ref?=':' conceptDef=[ConceptDef] |
//		('<' mapping=Mapping '>')? ('[' annotation+=Annotation (',' annotation+=Annotation)* ']')? body=ConceptDefBody?	
//	);

Annotation:
	key=ANNOTATION_ID ('=' value=STRING)?;

//ConceptDef:
//	(top?='/top'? named?='concept' name=ID)? ('<' mapping=Mapping '>')? 
//		('[' annotation+=Annotation (',' annotation+=Annotation)* ']')?
//		('{' localName=ID '}')?;

//ConceptDef:
//	AnonymousConceptDef | NamedConceptDef;
	
AnonymousConceptDef returns ConceptDef: {ConceptDef}
	('<' mapping=Mapping '>')? 
	('{' annotation+=Annotation* child+=SubconceptOrAttribute* '}')?;

NamedConceptDef returns ConceptDef:
	named?='concept' name=ID ('<' mapping=Mapping '>')? 
	('{' annotation+=Annotation* child+=SubconceptOrAttribute* '}')?;
	
TopConceptDef returns ConceptDef:
	top?='top' named?='concept' name=ID ('<' mapping=Mapping '>')? 
	('{' annotation+=Annotation* child+=SubconceptOrAttribute* '}')?;

SubconceptOrAttribute:
	Subconcept | Attribute;
			
Subconcept returns SubconceptOrAttribute:
	name=ID cardinality=Cardinality? (essential?='!'? | mustBeNull?='!!')
	((':' def=NamedConceptDef) | def=AnonymousConceptDef | (reference?=':' ref=[ConceptDef]));		
	
Attribute returns SubconceptOrAttribute:
	attrib?='attrib' name=ID cardinality=Cardinality? (essential?='!'? | mustBeNull?='!!')
	('<' attribMapping=Mapping '>')? 
	('{' annotation+=Annotation* '}')?;

//AnnotationID: '@' ID;

terminal ANNOTATION_ID : '@' ID;

//AnonymousConcept:
//	localName=ID cardinality=Cardinality? required?='!'? ('<' mapping=Mapping '>')? 
//	('[' annotation+=Annotation (',' annotation+=Annotation)* ']')?
//	body=ConceptDefBody?;

//Attribute:
//	'attrib' name=ID cardinality=Cardinality? required?='!'? ('<' mapping=Mapping '>')?
//	('[' annotation+=Annotation (',' annotation+=Annotation)* ']')?;

//ConceptDefBody:
//	'{' (subconcept+=Subconcept) (',' subconcept+=Subconcept)* '}';

//ConceptRef:
//	localName=ID cardinality=Cardinality? required?='!'? ':' name=[ConceptDef];
	
Cardinality:
	zeroOrMore?='*' |
	oneOrMore?='+';
	
Mapping:
	context=PathExpr? mapping=ImplicitContextMapping ('before' '(' before=PathExpr ')')? ('after' '(' after=PathExpr ')')?;

ImplicitContextMapping:
	Module | ModuleName | UsesModule | UsesEntity | 
	Call | Subroutine | SubroutineName | ActualParamByKeyword | 
	VariableDeclaration | {DeclaredEntity} DeclaredEntity |
	FunctionAssignment;

Module: {Module} 
	'module' ('(' name=Expr ')')?;
	
ModuleName: {ModuleName}
	'moduleName';
	
UsesModule:
	'usesModule' '(' name=Expr ')';
	
UsesEntity:
	'usesEntity' '(' name=Expr ')';

Subroutine:
	'subroutine' '(' name=Expr ('(' (params+=FormalParam (',' params+=FormalParam)* )? ')')? ')';
	
FormalParam:
	intent=Intent? type=Type name=Expr;

Intent:
	in?='in' | out?='out' | inout?='inout';

Type:
	integer?='integer' | 
	character?='character' | 
	logical?='logical' | 
	real?='real' |
	double?='double' ('precision')? |
	derived?='type' '(' derivedType=Expr ')';

SubroutineName:
	'subroutineName' {SubroutineName} ('(' name=Expr ')')?;

Call:
	'call' '(' subroutineName=Expr ( '(' (params+=ActualParam (',' params+=ActualParam)* )? ')')? ')';

ActualParam:
	(keyword=ID (optional?='?')? '=')? value=Expr;

ActualParamByKeyword:
	'actualParamByKeyword' '(' keyword=ID ')';
	
VariableDeclaration:
	'declaration' '(' type=Type ')';
	
DeclaredEntity:
	'declaredEntity';
	
FunctionAssignment:
	'functionAssignment' '(' lhs=Expr ',' functionName=Expr ( '(' (params+=ActualParam (',' params+=ActualParam)* )? ')')? ')';
	
//RightHandSideFunctionRef:
//	'rhsFunctionRef';



LocalExpression:
	id=ID | literal=Literal;
	
//IDOrPathExpr:
//	idOrWildcard=IDOrWildcard | pathExpr=PathExpr;

//three basic cases: 
// - a wildcard, 
// - a local expression in the target domain, 
// - or a path expression in the FSML domain	
//IDOrPathExpr:
Expr:
	wildcard?='*' | expr=LocalExpression | pathExpr=PathExpr;

Literal:
	INT+ | STRING;

//PathExpr:
//	'#' segments+=PathSegment ('/' segments+=PathSegment)*;
	
PathExpr:
	'#' PathExprNode;

//PathExprNode returns PathExpr:
//	PathExprTerm ({PathExpr.head=current} '/' tail=PathExprNode)?;

//PathExprTerm returns PathExpr:
//	{PathExprTerm} ref=[SubconceptOrAttribute] (guard?='['']')?;
	
PathExprNode returns PathExpr:
	PathExprTerm ({PathExpr.head=current} '/' tail=[SubconceptOrAttribute])*;

PathExprTerm returns PathExpr:
	{PathExprTerm} axis=Axis? ref=[SubconceptOrAttribute];	
	
Axis:
	ancestor?='^'
	//parent?='..'
	;

//PathSegment:
//	'..' | ID;
	
//PathExpr returns Ref:
 //   EntityRef ({PathExpr.ref=current}  "." tail=ID)*
//;
 
//EntityRef returns Ref:
 //   {EntityRef} entity=[SubconceptOrAttribute]
//; 
	
//override	
terminal SL_COMMENT: '--' !('\n'|'\r')* ('\r'? '\n')?;

//override
terminal ID : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
